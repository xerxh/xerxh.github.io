<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue首页加载白屏优化]]></title>
    <url>%2F2019%2F08%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[首页白屏的原因单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的js文件(app.js vendor.js)，所以当网速差的时候会产生一定程度的白屏。 解决优化方案路由懒加载在 router.js 的文件中,原来的静态引用方式,如: 123import ShowBlogs from '@/components/ShowBlogs'routes:[ path: 'Blogs', name: 'ShowBlogs', component: ShowBlogs ] 改成 12345routes:[ path: 'Blogs', name: 'ShowBlogs', component: () =&gt; import('./components/ShowBlogs.vue')] 将 JS 文件放在 body 的后面默认情况下, build 打包后的 index.html, js 的引入是在 head 中,使用html-webpack-plugin插件，将inject的值改为body。就可以将js引入放到body最后。 1234var HtmlWebpackPlugin = require('html-webpack-plugin');new HtmlWebpackPlugin(&#123; inject:'body'&#125;) 使用 CDN打包时，把vue、vuex、vue-router、axios等，换用国内的bootcdn直接引入到根目录的index.html。在webpack设置中添加externals，忽略不需要打包的库。 1234567891011module.exports = &#123; context: path.resolve(__dirname, '../'), entry: &#123; app: './src/main.js' &#125;, externals:&#123; 'vue':'Vue', 'vue-router':'VueRouter', 'vuex':'Vuex' &#125;, // 格式为'aaa':'bbb'，其中，aaa表示要引入的资源的名字，bbb表示该模块提供给外部引用的名字，由对应的库自定。例如，vue为Vue，vue-router为VueRouter 在 index.html 中判断是否是生产环境使用 CDN 引入 123456&lt;% if (NODE_ENV === 'production') &#123; %&gt; &lt;script src="//cdn.bootcss.com/vue/2.2.5/vue.min.js"&gt;&lt;/script&gt; &lt;script src="//cdn.bootcss.com/vue-router/2.3.0/vue-router.min.js"&gt;&lt;/script&gt; &lt;script src="//cdn.bootcss.com/vuex/2.2.1/vuex.min.js"&gt;&lt;/script&gt; &lt;script src="//cdn.bootcss.com/axios/0.15.3/axios.min.js"&gt;&lt;/script&gt;&lt;% &#125; %&gt; 去掉原有的引用,否则还是会打包 123456//去掉import，如：//import Vue from &apos;vue&apos;//import Router from &apos;vue-router&apos;//去掉Vue.use(XXX)，如：//Vue.use(Router) 压缩代码,移除 console使用UglifyJsPlugin插件来压缩代码和移除console 1234567891011new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_console:true, pure_funcs:[&apos;console.log&apos;] &#125; &#125;, sourceMap: config.build.productionSourceMap, parallel: true &#125;), gzip压缩参数配置文档: https://www.webpackjs.com/plugins/compression-webpack-plugin 12345678910111213141516171819// 需要 npm install compression-webpack-plugin --save-devconst CompressionWebpackPlugin = require('compression-webpack-plugin')// 定义当前环境const ENV = process.env.NODE_ENV || 'development'module.exports = &#123; configureWebpack: config =&gt; &#123; // 如果是开发环境的话，开启压缩 if (ENV === 'production') &#123; config.plugins.push(new CompressionWebpackPlugin(&#123; algorithm: 'gzip', test: /\.(js|css|html)$/, threshold: 10240, //对超过10k的数据进行压缩 minRatio: 0.8 &#125;)) &#125; &#125;&#125; 代码分割 Code Splitting参数配置文档: https://webpack.js.org/guides/code-splitting 分割业务代码和库代码, 不然打包文件会很大, 首次访问加载时间会很长 而且如果不分割, 修改业务代码后, 重新访问, 又全部得重新加载库代码 分割方式: 配置 + 同步引入 与 动态引入(无需做任何配置) 动态引入文档: https://webpack.js.org/guides/code-splitting#dynamic-imports 1234567891011121314151617181920function getComponent () &#123; // jsonp引入 // 动态的import, 实验性的语法 // npm i babel-plugin-dynamic-import-webpack -D return import('lodash').then((&#123; default: _ &#125;) =&gt; &#123; var element = document.createElement('div') element.innerHTML = _.join(['a', 'b'], '*') return element &#125;)&#125;getComponent().then(element =&gt; &#123; document.body.appendChild(element)&#125;)// .babelrc 动态引入// npm i -D babel-plugin-dynamic-import-webpack&#123; plugins: ['dynamic-import-webpack']&#125; SplitChunksPlugin官方文档: https://webpack.js.org/plugins/split-chunks-plugin/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// splitPlugin 配置optimization: &#123; // SplitChunksPlugin config // 如下是官方默认配置 splitChunks: &#123; // async 只对异步代码生效 // all 对同步异步都做代码分割, 但是同步代码还需cacheGrops配置 // initial 只对同步代码做分割 chunks: 'async', // 如果引入的模块大于minSize才做代码分割 minSize: 30000, // 对于大于maxsize的模块尝试进行二次代码分割 maxSize: 0, // 打包后的文件至少有多少个chunk文件引入这个模块才进行代码分割 minChunks: 1, // 同时加载的模块数量, // 在打包前5个库的时候会生成5个js文件, // 超过5个就不再做代码分割 maxAsyncRequests: 5, // 入口文件做代码分割的最大文件数量 maxInitialRequests: 3, // 自动命名定界符 automaticNameDelimiter: '~', // 让cacheGroups里的filename生效 name: true, // 缓存组, 把库文件先放到缓存里, 再根据test规则分组合并打包 cacheGroups: &#123; // vendors: false vendors: &#123; // 如果是node_modules里面的文件, 就打包到vendors组里 test: /[\\/]node_modules[\\/]/, // 分组时的优先级 priority: -10 // // 组文件的名字 vendors.js, 不然会是 vendors~main.js // filename: 'vendors.js' &#125;, // 被分割的代码的默认的配置, 没有test, 所有模块都符合要求 default: &#123; // 至少被引用了2次 minChunks: 2, priority: -20, // 复用已被分割打包过了的模块 reuseExistingChunk: true, // // 组的文件名 // filename: 'common.js', &#125; &#125; &#125; &#125; tree shaking 根据引入的按需打包, 摇晃掉模块里与树没有关联的无用的模块官方文档: https://webpack.js.org/guides/tree-shaking 官方文档: https://webpack.js.org/configuration/optimization#optimizationusedexports 关于静态模块结构的官方文档: https://exploringjs.com/es6/ch_modules.html#static-module-structure 12345678910111213141516// Tree Shaking只支持 ES Module(静态引入), 不支持Common JS(动态引入)// development mode 默认没有tree shaking// production mode 不需要这个optimizationoptimization: &#123; usedExports: true&#125;// package.json"sideEffects": false, // false时对所有模块摇树// 实践"sideEffects": [ // 不然打包时会忽略 @babel/polly-fill, 因为其没有导出对象, 只在window上挂载了对象 "@babel/polly-fill", // 对css不摇树 "*.css"], sourcemap 源码映射官方文档: https://webpack.js.org/configuration/devtool#devtool 12345678devtool: 'none' // 关闭sourcemapdevtool: 'source-map' // 会生成一个.map文件devtool: 'inline-source-map' // .map文件会被打包到js文件里, 错误提示会精确到第几行第几列devtool: 'cheap-inline-source-map' // 只精确到行, 不精确到列, 提示性能, 而且只会提示业务代码的错误, 不提示loader和第三方模块的错误devtool: 'cheap-module-inline-source-map' // 提示loader和第三方模块的错误devtool: 'eval' // 用js eval效率最高, 提示不全面, 不展示行数devtool: 'cheap-module-eval-source-map' // 开发时的最佳实践devtool: 'cheap-module-source-map' // 生产时的最佳实践 SSR]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
