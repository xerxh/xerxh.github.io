<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2019%2F10%2F09%2Fwebpack%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[design-Patterns]]></title>
    <url>%2F2019%2F09%2F04%2Fdesign-Patterns%2F</url>
    <content type="text"><![CDATA[设计模式单例模式定义：单例模式的定义是保证一个类仅有一个实例。在js开发中如果我们需要点击一个登陆按钮，出现一个登陆浮窗，而这个浮窗也应该是全局唯一的。无论点击多少次，这个浮窗也只会创建一次。这时候我们就需要使用单例模式进行创建。 其实要实现一个单例模式并不复杂，主要原理是通过用一个变量来标志是否已经创建过实例，如果是直接将实例返回，不是则新建一个实例并修改变量标记做好创建记录，下次获取时直接返回实例。 光说好像不太能理解那么下面让我们来实现一个最简单的单例模式把。 12345678910111213141516171819// 实现js一个登陆类var Singleton = function(name)&#123; this.name = &apos;sing class&apos; this.instance = null; // 是否实例的标记&#125;Singleton.prototype.getName = function()&#123; alert(this.name)&#125;// 为类向外提供一个获取单例的方法Singleton.getInstance = function()&#123; // 通过判断标记变量是否已经有实例 如果有 直接返回实例 如果没有生成一个新的实例返回并保存实例 if(!this.instance)&#123; this.instance = new Singleton() &#125; return this.istance&#125;var aSing = Singleton.getInstance()var bSing = Singleton.getInstance()console.log(aSing === bSing) // true 两者完全相等是同一个实例 好了我们已经完成了一个简单的单例了，感觉是不是很简单呢,但在实际开发中我们这种简单的单例并不具备太多的可用性，因为Singleton的使用者必须知道这是一个单例类，而且与通过 new 获取类的实例化不同,这里需要用方法进行获取。因此我们需要一步步进行深入完成更好的单例模式。 透明的单例模式目标：实现一个”透明”的单例类,我们在从这个类中创建对象时,可以像使用其他类一样使用 new 进行实例化,从而改进了上面的缺点,将单例进行隐藏了,所以叫透明的单例模式 12345678910111213141516171819202122// 现在我们将实现一个createDiv类 它的作用是负责在页面中创建唯一的div节点// 可实际应用在全局提示 获取 全局弹窗等地方var CreateDiv = (function()&#123; var instance var CreateDiv = function(html)&#123; if(instance)&#123; return instance &#125; this.html = html this.init() return instance = this &#125; CreateDiv.prototype.init = function()&#123; var div = document.createElement(&apos;div) div.html = this.html document.body.appendChild(&apos;div&apos;) &#125; return CreateDiv&#125;)()var a = new CreateDiv()var b = new CreateDiv()console.log(a === b) // true 好了 我们现在完成了透明单例的实现，但是它还是有很多的缺点。 为了把单例封装隐藏起来，我们使用了自执行的匿名函数和闭包，并且让匿名函数返回真正的单例构造方法，增加了一定的代码复杂度，而且阅读也不是很好理解。 我们观察我们现在的实例构造函数,在函数中实际我们完成了两件事,第一件事是创建和执行初始化init方法，第二是保证只有一个对象。但设计模式中都需要遵循”单一职责原则”即一个函数只干一件事,保证尽量精简。 单一原则主要是为了未来的可扩展和可维护性，假如有一天我们需求变了需要利用这个类，在页面中创建多个div，即要让这个类可以变成同时产生多个实例的普通类，那我们就必须进行改写createDiv构造函数,把控制创建唯一对象的代码去掉这样的修改会给我们带来不必要的烦恼。 为了解决上面所说的缺点我们可以通过引入代理类的方式来解决。 代理模式实现代理模式我们先创建一个普通的单一的创建div的类123456789var CreateDiv = function(html)&#123; this.html = html this.init()&#125;CreateDiv.prototype.init = function()&#123; var div = document.createElement(&apos;div&apos;) div.innerHtml = this.html document.body.appendChild(&apos;div&apos;)&#125; 然后我们引入代理类 proxySingletonCreateDiv 123456789101112var proxySingletonCreateDiv = (function()&#123; var instance return function(html)&#123; if(!instance)&#123; instance = new CreateDiv(html) &#125; return instance &#125;&#125;)()var a = new proxySingletonCreateDiv(&apos;sven1&apos;)var b = new proxySingletonCreateDiv(&apos;sven2&apos;)console.log(a === b) // true 我们通过引入了一个代理类的方式，完成了一个新的单例模式，但与原先不同的是我们把负责管理单例的逻辑移到了代理类proxySingletonCreateDiv中，从而保证了创建div类的单一性，只有当和proxySingtonCreateDiv结合才形成单例的效果，如果未来需要改成生成多个 我们只需要再扩展一个新的结合的代理类即可实现。保证了极大的扩展性和可维护性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[前后端跨域方法总结]]></title>
    <url>%2F2019%2F08%2F07%2Fstudy-1%2F</url>
    <content type="text"><![CDATA[什么叫跨域？跨域，指的是从一个域名去请求另外一个域名的资源。即跨域名请求,跨域时,浏览器不能执行其他域名网站的脚本，这是由于浏览器的同源策略造成的，是浏览器施加的安全限制。 所以我们需要了解一下什么叫同源策略？同源策略是由 Netscape(网景公司) 提出的一个著名的安全策略，浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。所有支持 JavaScript 的浏览器都会使用这个策略。当页面在执行一个脚本时会检查访问的资源是否同源，如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。 那么浏览器是出于什么安全性考虑呢？最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。 设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？ 如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。 Cookie 现在在浏览器往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。 因此”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 然后再设想如果没有限制不同域 dom 元素的访问，会发生什么？ 有一天你收到一封邮件，说是你的银行账号有风险，赶紧点进www.yinghang.com改密码。你吓尿了，赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了 急躁的你没看清楚，平时访问的银行网站是www.yinhang.com，而现在访问的是www.yinghang.com，那么这个钓鱼网站会做什么呢？ 会利用 iframe 将银行页面嵌入钓鱼网站 1&lt;iframe name=&quot;yinhang&quot; src=&quot;www.yinhang.com&quot;&gt;&lt;/iframe&gt; 然后利用 JS 123const iframe = window.frames[&apos;yinhang&apos;] const node = iframe.document.getElementById(&apos;你输入账号密码的Input&apos;)console.log(`拿到了这个$&#123;node&#125;，好了 你的密码已经到手了`) 因此同源策略的重要性不言而喻，同时随着互联网的发展和进步，为了更进一步的安全性考虑，同源策略变得原来越严格而完善。目前主要有以下三种行为受到限制。 Cookie、LocalStorage 和 IndexDB 无法读取。 DOM 无法获得 AJAX 请求不能发送。 那么什么样的是同源呢？ 同协议：都是 http / https 同域名：如都是 http://example.com/a 和 http://example.com/b 同端口：都是相同的端口号 三者同时满足才属于同源 不同源示例： http://example.com 和 https://example.com (协议不同) http://example.com 和 http://example.cn (域名不同) http://example.com 和 http://example.com:8080 (端口号不同) 跨域的解决方案刚上面了解了跨域的安全性作用和必要性，但有时候由于这种安全性策略会导致很多的不方便，有些合理性的用途也会受到影响。因此我们需要对这些跨域问题进行解决达成我们的用途。 JSONP CORS Server Proxy (服务器代理) document.domain(降域) postMessage location.hash window.name nginx websocket (没有同源限制) JSONPJSON是一种比较常见的解决跨域的方法 window.namelocation.hashpostMessagedocument.domainCORS]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue首页加载白屏优化]]></title>
    <url>%2F2019%2F08%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[首页白屏的原因单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的js文件(app.js vendor.js)，所以当网速差的时候会产生一定程度的白屏。 解决优化方案路由懒加载在 router.js 的文件中,原来的静态引用方式,如: 123import ShowBlogs from '@/components/ShowBlogs'routes:[ path: 'Blogs', name: 'ShowBlogs', component: ShowBlogs ] 改成 12345routes:[ path: 'Blogs', name: 'ShowBlogs', component: () =&gt; import('./components/ShowBlogs.vue')] 将 JS 文件放在 body 的后面默认情况下, build 打包后的 index.html, js 的引入是在 head 中,使用html-webpack-plugin插件，将inject的值改为body。就可以将js引入放到body最后。 1234var HtmlWebpackPlugin = require('html-webpack-plugin');new HtmlWebpackPlugin(&#123; inject:'body'&#125;) 使用 CDN打包时，把vue、vuex、vue-router、axios等，换用国内的bootcdn直接引入到根目录的index.html。在webpack设置中添加externals，忽略不需要打包的库。 1234567891011module.exports = &#123; context: path.resolve(__dirname, '../'), entry: &#123; app: './src/main.js' &#125;, externals:&#123; 'vue':'Vue', 'vue-router':'VueRouter', 'vuex':'Vuex' &#125;, // 格式为'aaa':'bbb'，其中，aaa表示要引入的资源的名字，bbb表示该模块提供给外部引用的名字，由对应的库自定。例如，vue为Vue，vue-router为VueRouter 在 index.html 中判断是否是生产环境使用 CDN 引入 123456&lt;% if (NODE_ENV === 'production') &#123; %&gt; &lt;script src="//cdn.bootcss.com/vue/2.2.5/vue.min.js"&gt;&lt;/script&gt; &lt;script src="//cdn.bootcss.com/vue-router/2.3.0/vue-router.min.js"&gt;&lt;/script&gt; &lt;script src="//cdn.bootcss.com/vuex/2.2.1/vuex.min.js"&gt;&lt;/script&gt; &lt;script src="//cdn.bootcss.com/axios/0.15.3/axios.min.js"&gt;&lt;/script&gt;&lt;% &#125; %&gt; 去掉原有的引用,否则还是会打包 123456//去掉import，如：//import Vue from &apos;vue&apos;//import Router from &apos;vue-router&apos;//去掉Vue.use(XXX)，如：//Vue.use(Router) 压缩代码,移除 console使用UglifyJsPlugin插件来压缩代码和移除console 1234567891011new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_console:true, pure_funcs:[&apos;console.log&apos;] &#125; &#125;, sourceMap: config.build.productionSourceMap, parallel: true &#125;), gzip压缩参数配置文档: https://www.webpackjs.com/plugins/compression-webpack-plugin 12345678910111213141516171819// 需要 npm install compression-webpack-plugin --save-devconst CompressionWebpackPlugin = require('compression-webpack-plugin')// 定义当前环境const ENV = process.env.NODE_ENV || 'development'module.exports = &#123; configureWebpack: config =&gt; &#123; // 如果是开发环境的话，开启压缩 if (ENV === 'production') &#123; config.plugins.push(new CompressionWebpackPlugin(&#123; algorithm: 'gzip', test: /\.(js|css|html)$/, threshold: 10240, //对超过10k的数据进行压缩 minRatio: 0.8 &#125;)) &#125; &#125;&#125; 代码分割 Code Splitting参数配置文档: https://webpack.js.org/guides/code-splitting 分割业务代码和库代码, 不然打包文件会很大, 首次访问加载时间会很长 而且如果不分割, 修改业务代码后, 重新访问, 又全部得重新加载库代码 分割方式: 配置 + 同步引入 与 动态引入(无需做任何配置) 动态引入文档: https://webpack.js.org/guides/code-splitting#dynamic-imports 1234567891011121314151617181920function getComponent () &#123; // jsonp引入 // 动态的import, 实验性的语法 // npm i babel-plugin-dynamic-import-webpack -D return import('lodash').then((&#123; default: _ &#125;) =&gt; &#123; var element = document.createElement('div') element.innerHTML = _.join(['a', 'b'], '*') return element &#125;)&#125;getComponent().then(element =&gt; &#123; document.body.appendChild(element)&#125;)// .babelrc 动态引入// npm i -D babel-plugin-dynamic-import-webpack&#123; plugins: ['dynamic-import-webpack']&#125; SplitChunksPlugin官方文档: https://webpack.js.org/plugins/split-chunks-plugin/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// splitPlugin 配置optimization: &#123; // SplitChunksPlugin config // 如下是官方默认配置 splitChunks: &#123; // async 只对异步代码生效 // all 对同步异步都做代码分割, 但是同步代码还需cacheGrops配置 // initial 只对同步代码做分割 chunks: 'async', // 如果引入的模块大于minSize才做代码分割 minSize: 30000, // 对于大于maxsize的模块尝试进行二次代码分割 maxSize: 0, // 打包后的文件至少有多少个chunk文件引入这个模块才进行代码分割 minChunks: 1, // 同时加载的模块数量, // 在打包前5个库的时候会生成5个js文件, // 超过5个就不再做代码分割 maxAsyncRequests: 5, // 入口文件做代码分割的最大文件数量 maxInitialRequests: 3, // 自动命名定界符 automaticNameDelimiter: '~', // 让cacheGroups里的filename生效 name: true, // 缓存组, 把库文件先放到缓存里, 再根据test规则分组合并打包 cacheGroups: &#123; // vendors: false vendors: &#123; // 如果是node_modules里面的文件, 就打包到vendors组里 test: /[\\/]node_modules[\\/]/, // 分组时的优先级 priority: -10 // // 组文件的名字 vendors.js, 不然会是 vendors~main.js // filename: 'vendors.js' &#125;, // 被分割的代码的默认的配置, 没有test, 所有模块都符合要求 default: &#123; // 至少被引用了2次 minChunks: 2, priority: -20, // 复用已被分割打包过了的模块 reuseExistingChunk: true, // // 组的文件名 // filename: 'common.js', &#125; &#125; &#125; &#125; tree shaking 根据引入的按需打包, 摇晃掉模块里与树没有关联的无用的模块官方文档: https://webpack.js.org/guides/tree-shaking 官方文档: https://webpack.js.org/configuration/optimization#optimizationusedexports 关于静态模块结构的官方文档: https://exploringjs.com/es6/ch_modules.html#static-module-structure 12345678910111213141516// Tree Shaking只支持 ES Module(静态引入), 不支持Common JS(动态引入)// development mode 默认没有tree shaking// production mode 不需要这个optimizationoptimization: &#123; usedExports: true&#125;// package.json"sideEffects": false, // false时对所有模块摇树// 实践"sideEffects": [ // 不然打包时会忽略 @babel/polly-fill, 因为其没有导出对象, 只在window上挂载了对象 "@babel/polly-fill", // 对css不摇树 "*.css"], sourcemap 源码映射官方文档: https://webpack.js.org/configuration/devtool#devtool 12345678devtool: 'none' // 关闭sourcemapdevtool: 'source-map' // 会生成一个.map文件devtool: 'inline-source-map' // .map文件会被打包到js文件里, 错误提示会精确到第几行第几列devtool: 'cheap-inline-source-map' // 只精确到行, 不精确到列, 提示性能, 而且只会提示业务代码的错误, 不提示loader和第三方模块的错误devtool: 'cheap-module-inline-source-map' // 提示loader和第三方模块的错误devtool: 'eval' // 用js eval效率最高, 提示不全面, 不展示行数devtool: 'cheap-module-eval-source-map' // 开发时的最佳实践devtool: 'cheap-module-source-map' // 生产时的最佳实践 SSR]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
